# 04 - 재귀 & 백트래킹



## 재귀

### 정의

하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

### 수학적 귀납법

어떤 문제를 재귀로 푼다는 것 = 귀납적인 방식으로 문제를 해결하는 것

[도미노 예시]

1. 절차 지향적 사고
   1번이 쓰러지면 2번이 쓰러진다 → 2번이 쓰러지면 3번이 쓰러진다 → ... 
   ⇒ 모든 도미노가 쓰러진다
2. 수학적 귀납법
   1번 도미노가 쓰러진다 → k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다 
   ⇒ 모든 도미노가 쓰러진다

### 재귀 함수의 조건

1. 특정 입력에 대해서 자기 자신을 호출하지 않고 종료되어야 함
2. 모든 입력은 base condition으로 수렴해야 함

하나라도 지켜지지 않으면 무한재귀 발생 ⇒ 런타임 에러

```cpp
int fibo(int n) {
	if(n<=1) return 1; // base condition
	return fibo(n-1) + fibo(n-2);
}
```

### TIP!

1. 함수를 명확하게 정의해야 함
   (인자로 어떤 것을 받고, 어디까지 계산한 후 자기 자신에게 넘겨줄 지)

2. 모든 재귀 함수는 반복문만으로 동일한 동작을 함수를 만들 수 있음

3. 재귀 함수는 반복문보다 비교적 코드가 간결하지만 메모리/시간에서는 손해를 봄
   (굳이 재귀를 쓰지 않아도되면 반복문을 사용하는 것이 좋음)

4. 한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음
   - 피보나치 수열
   - 중복된 계산이 계속 발생해 시간복잡도가 매우 커짐

5. 재귀함수가 자기 자신을 부를 때 스택 영역에 계속 누적이 됨
   - 스택 영역(메모리 구조)에 함수에 대한 정보와 지역 변수가 누적됨
   - 문제를 풀 때 메모리 제한이 존재
   - 일부 컴파일 환경에서는 스택 영역의 메모리가 별도로 제한되어 있음



## 백트래킹

### 정의

- 현재 상태에서 가능한 모든 후보군을 따라 들어가며 탐색하는 알고리즘
- 현재 상태에서 가능한 모든 선택지를 다 해보는 방법
- ex) 시뮬레이션 게임, 선택지 중 하나를 택하는 경우

### STL next_permutation

- 순열과 조합을 사용할 때
- 백트래킹은 실수할 여지가 있고 코드도 길어짐
- next_permutation 함수를 사용하면 깔끔하게 순열과 조합 해결 가능
- [reference](http://www.cplusplus.com/reference/algorithm/next_permutation/)
